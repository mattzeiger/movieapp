var mysql = require('../mysql');
var unique = require('../array-unique'); //used to unique an array //unique(['a', 'b', 'c', 'c']);
var dateformatl = require('../date-format-lite');
var db = require('../dbConnection');
var connection = db();

//schema:
/*
var movieobj = {
	source : 'itunes',
	source_id : movieResults['id'], 
	movie_name : movie_name,
	alt_title : alt_title,
	movie_year : movie_year,
	rating : movieResults['contentRating'].name, 
	releaseDate : movieResults['releaseDate'],
	rental_price : rental_price,
	rental_price_hd : rental_price_hd,
	purchase_price : purchase_price,
	purchase_price_hd : purchase_price_hd,
	coming_soon : coming_soon,
	isEdition : isEdition
};
*/

exports.captureMovie = function(movieobj, callback) {
	//first, attempt to find the movie_id based on source_id (the itunes unique key)
	var query = connection.query('SELECT movie.id, movie.title, movie.year, movie.edition_label, movie.parent_id, moviesource.id as moviesourceid FROM movie LEFT JOIN moviesource ON movie.id = moviesource.movie_id AND moviesource.source = \'' + movieobj.source + '\' WHERE moviesource.source_id = ? ', movieobj.source_id , function (err,rows,fields) {
		if (err) throw err;		
		if (rows.length > 0) { //we found the movie, based on the iTunes key!
			var movierow;
			movierow = rows[0];

			//go ahead and correct the title and the edition fields if its an edition
			if (movieobj.isEdition != '') {
				//Look for the Parent: see if this title and approximate year match another movie (i.e. attempt to find the parent movie for this edition)
				var query = connection.query("SELECT id FROM movie WHERE (movie.title = ? OR movie.alt_title = ?) AND (movie.year >= (?-1) AND movie.year <= (?+1)) AND parent_id=0 AND (edition_label = '' OR edition_label IS NULL) AND movie.id <> ? ", [movieobj.movie_name, movieobj.movie_name, movierow.year, movierow.year, movierow.id], function (err,rows) {
					if (err) throw err;		
					var parent_id = movierow.parent_id;
					if (rows.length > 0 && parent_id == 0) {
						parent_id = rows[0].id;						
					}

					var query = connection.query('UPDATE movie SET movie.title = ?, alt_title = ?, movie.edition_label = ?, parent_id = ? WHERE id = ?', [movieobj.movie_name, movieobj.alt_title, movieobj.isEdition, parent_id, movierow.id], function (err,rows) {
						if (err) throw err;		
						//updated the title and edition					

					});

				});			
			}
			//Update the moviesource info				
			updateMovieSource(movieobj, movierow.id, movierow.moviesourceid, callback);
		} else {
			//if this fails, then 
			//locate based on title or alt_title and approximate year
			var query = connection.query('SELECT movie.id, movie.title, movie.year, movie.mpaa, movie.edition_label, movie.parent_id, moviesource.id as moviesourceid FROM movie LEFT JOIN moviesource ON movie.id = moviesource.movie_id AND moviesource.source = \'' + movieobj.source + '\' WHERE (movie.title = ? OR movie.alt_title = ?) AND (movie.year >= (?-1) AND movie.year <= (?+1)) ORDER BY movie.release_date ASC;', [movieobj.movie_name, movieobj.movie_name, movieobj.movie_year, movieobj.movie_year], function (err,rows, fields) {				
				var parent_id = 0;
				if (rows.length == 1) {
					movierow = rows[0];
				} else if (rows.length > 1) { //see if there is more than one...
					//see if our movie record is an edition
					if (movieobj.isEdition != '') {
						//it is! then a few possibilities...
						var matched = false;
						var potential_parent = new Array();
						//a) we've already imported this edition, and need to try to match it to the one we've imported before
						//loop through the movies
						for (var i = 0;i<rows.length;i++) {
							//see if isEdition = edition_label
							if (movieobj.isEdition == rows[i].edition_label) {									
								//it is, then movierow = rows[i];
								movierow = rows[i];
								matched = true;
							} else {
								if (rows[i].parent_id == 0) {
									potential_parent.push(i);
								}
							}			
						}
						//end loop

						if (!matched) {
							//b) we've never imported this edition, but we should go ahead and try to match it up against an original theatrical release
							//find the movies that parent_id = 0, and preferably mpaa != 0
							if (potential_parent.length > 0) {
								parent_id = rows[potential_parent[0]].id; //match it up to the first one by default
								for (var i = 0;i<potential_parent.length;i++) {
									if (rows[potential_parent[i]].mpaa == 0) {
										parent_id = rows[potential_parent[i]].id;
										break;
									}
								}								
							}								
						}
					} else {
						//its not an edition, and so let's just go with the first one (oldest release date)
						movierow = rows[0];						
					}
				} 
				if (movierow) {
					//console.log('Found a movie');
					//it does, then check to see if there is an iTunes record for it
					if (movierow.moviesourceid > 0) {
						//there is, then update it (specifically the moviesource info)
						//Update the moviesource info				
						updateMovieSource(movieobj, movierow.id, movierow.moviesourceid, callback);
					} else {
						//console.log('there is not, then create the iTunes moviesource record for this movie');
						updateMovieSource(movieobj, movierow.id, 0, callback);
					}
				} else {
					//console.log('Create the movie');

					//[0=NR,1=G,2=PG,3=PG-13,4=R,5=NC-17]
					var contentRating = 0;
					if (movieobj.contentRating == 'G') {
						contentRating = 1;
					} else if (movieobj.contentRating == 'PG') {
						contentRating = 2;
					} else if (movieobj.contentRating == 'PG-13') {
						contentRating = 3;
					} else if (movieobj.contentRating == 'R') {
						contentRating = 4;
					} else if (movieobj.contentRating == 'NC-17') {
						contentRating = 5;
					}

					var movie_db = { //meta-data retrieval happens elsewhere
						title : movieobj.movie_name,
						alt_title : movieobj.alt_title,
						year : movieobj.movie_year,
						mpaa : contentRating,				
						description : '',
						genre_primary : '',
						director_id : 0,
						duration : '',
						studio : '',
						budget : '',
						release_date : movieobj.releaseDate,
						box_office : '',
						edition_label: movieobj.isEdition,
						parent_id : parent_id
					};
					//console.log(moviedata);										
					//it doesn't? then create the movie record
					var query = connection.query('INSERT INTO movie set ? ', movie_db, function(err,result,fields) {				
						//create the moviesource record as well...				
						updateMovieSource(movieobj, result.insertId, 0, callback);				
					});			
				}
			
			});

		}
	});	
};



function updateMovieSource(movieobj, movie_id, moviesource_id, callback) {
	//create the moviesource record for this movie
	
	//@@@make sure this movieobj.source_id isn't already in moviesource table...	
	var query = connection.query("SELECT id, movie_id, source_id FROM moviesource WHERE source = '" + movieobj.source + "' AND source_id = ? ORDER BY movie_id DESC ", movieobj.source_id, function(err, rows) {
		//it is there, then 
		if (rows.length > 0) {
			//lets go ahead and make sure this movie_id matches the one we found
			if (rows[0].movie_id != movie_id) {
				//it doesnt! uh oh... we have a duplicate movie, our current movie_id and the movie_id we found are duplicates since there are two movie_ids that have the same itunes source_id....
				//lets delete the higher movie_id, since thats a newer one, also only if active = 0, since we dont want to mess up live data
				var deleting_id = rows[0].movie_id;
				if (movie_id > deleting_id) {
					deleting_id = movie_id;
					movie_id = rows[0].movie_id; //change the reference of this moviesource we have found to be the right movie
				}
				var query = connection.query("DELETE FROM movie WHERE id = ? AND active = 0 LIMIT 1;", deleting_id, function(err,rows) {
					//deleting a duplicate movie 

				});					
			}
			//if (moviesource_id == 0) { //no matter which one we were trying to udpate, we're forcing it to be the first one...
				moviesource_id = rows[0].id; //we are now updating this moviesource, since there's one with this itunes source id already
			//}
			if (rows.length > 1) { //delete the other moviesources
				for(var i = 1;i<rows.length;i++) {
					var query = connection.query("DELETE FROM moviesource WHERE id = ?", rows[i].id, function(err, rows) {
						//deleted the duplicate moviesources!
					});
				}
			}
		}
		var now = new Date();
		var data = {
			movie_id : movie_id,
			source : 'itunes',
			source_id : movieobj.source_id,
			free : 0,//				[1/0]	--denotes if it is truly free
			subscription_free : 0, // 	[1/0]	--denotes free with subscription (i.e. hulu + or Netflix)
			rental_price : movieobj.rental_price,
			purchase_price : movieobj.purchase_price,
			rental_price_hd : movieobj.rental_price_hd,
			purchase_price_hd : movieobj.purchase_price_hd,
			cc : 0,
			coming_soon: movieobj.coming_soon		
		};
		if (moviesource_id > 0) {
			data.dateupdated = now.format("YYYY-MM-DD hh:mm");
			connection.query('UPDATE moviesource set ? WHERE id = ?', [data,moviesource_id], function(err, rows, fields) {
				return callback();
			});	
		} else {		
			data.dateadded = now.format("YYYY-MM-DD hh:mm");
			connection.query('INSERT INTO moviesource set ? ', data, function(err, rows, fields) {
				return callback();
			});	
		}
	});	
}



//An edition is a version of an original film (e.g. Director's Cut, etc.).
//Keywords to match an edition: Director, Unrated, Extended within a () or []
exports.detectEdition = function(movietitle) {
	movietitle = strip3D(stripYears(movietitle.trim()));
	var match = movietitle.match(/(\s*(\(|\[).*(director|unrated|extended|edition).*?(\)|\])|\s*(\[)(dubbed|subtitled)(\]))/gi);
	if (match !== null) {
		var holdstr = '';
		for(var j = 0;j<match.length;j++) {
			holdstr += match[j].trim() + ',';
		}
		return holdstr.substr(0, holdstr.length - 1);
	} else {
		return '';
	}
};

//normalize the movie title (removing additional things like "(2015) or (Watch Now)"")	
exports.normalizeMovieTitle = function(movietitle) {
	var thereturn = movietitle;
	thereturn = thereturn.trim();
	thereturn = strip3D(stripYears(thereturn));

	thereturn = thereturn.replace(/(\s*(\(|\[).*(director|unrated|extended|edition).*?(\)|\])|\s*(\[)(dubbed|subtitled)(\]))/gi, '');

	//if it ends on a right ) and the corresponding left ( doesn't start the string, then cut it from the string
	if ((thereturn[thereturn.length - 1] == ')') || (thereturn[thereturn.length - 1] == ']')) {
		for(var i = (thereturn.length - 1);i>=0;i--) {
			if ((thereturn[i] == '(') || (thereturn[i] == '[')) {
				if (i != 0) {
					thereturn = thereturn.substr(0, i-1);
					thereturn = thereturn.trim();
				}
				break;
			}
		}
	}
	// if there is a hyphen - directly to the left of the ( then cut that too
	if (thereturn[thereturn.length - 1] == '-') {
		thereturn = thereturn.substr(0, thereturn.length - 2);
		thereturn = thereturn.trim();
	}

	//if there is 'Anniversary' to the right of the - then cut everything to the right of the hyphen -
	var holdsplit = thereturn.split('-');	
	var match = holdsplit[0].match(/anniversary/gi);
	if (match !== null) {
		thereturn = holdsplit[0];
	}
	
	return thereturn;
};

function stripYears(somestr) {	
	return somestr.replace(/\s*(\(|\[)(\d{4})(\)|\])/, '').trim();
}
function strip3D(somestr) {
	return somestr.replace(/\s*(\(|\[)(\d{1})D(\)|\])/, '').trim();
}